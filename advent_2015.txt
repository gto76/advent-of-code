from enum import Enum
from collections import namedtuple


# Position Tuple
P = namedtuple('P', list('xy'))


def problem_1(data):
    out_a, out_b = 0, None
    for i, a in enumerate(data, 1):
        if a == '(':
            out_a += 1
        else:
            out_a -= 1
        if out_a == -1 and not out_b:
            out_b = i
    return out_a, out_b


def problem_2(data):
    def paper_for_box(l, w, h):
        x, y, z = l*w, w*h, h*l
        return 2*x + 2*y + 2*z + min(x, y, z)
    def ribbon_for_box(box):
        box.sort()
        return 2*box[0] + 2*box[1] + box[0]*box[1]*box[2]
    lines = data.split()
    int_data = [[int(side) for side in box.split(sep='x')] for box in lines]
    out_a = sum([paper_for_box(*box) for box in int_data])
    out_b = sum([ribbon_for_box(box) for box in int_data])
    return out_a, out_b


def problem_3(data):
    D = Enum('D', {'n': '^', 'e': '>', 's': 'v', 'w': '<'})
    def move(position, direction):
        MOVE = {D.n: P(-1, 0), D.e: P(0, 1), D.s: P(1, 0), D.w: P(0, -1)}
        return P(*[sum(a) for a in zip(position, MOVE[direction])])
    def get_visited_houses(path):
        position = P(0, 0)
        visited_houses = {position}
        for direction in path:
            position = move(position, direction)
            visited_houses.add(position)
        return visited_houses
    path = [D(a) for a in data]
    out_a = len(get_visited_houses(path))
    houses_santa = get_visited_houses(path[::2])
    houses_robo_santa = get_visited_houses(path[1::2])
    out_b = len(houses_santa.union(houses_robo_santa))
    return out_a, out_b


def problem_4(data):
    import hashlib
    def check(key, no_zeros):
        m = hashlib.md5()
        m.update(key.encode())
        hex_hash = m.digest().hex()
        return hex_hash.startswith('0'*no_zeros)
    out_a = 0
    while not check(f'{data}{out_a}', 5):
        out_a += 1
    out_b = 0
    while not check(f'{data}{out_b}', 6):
        out_b += 1
    return out_a, out_b


def problem_5(data):
    def is_nice_a(a_str):
        three_vowels = len(re.findall('[aeiou]', a_str)) >= 3
        twice_in_row = re.search('(.)\\1', a_str) 
        forbidden = re.search('ab|cd|pq|xy', a_str)
        return three_vowels and twice_in_row and not forbidden
    def is_nice_b(a_str):
        pair = re.search('(..).*\\1', a_str)
        repeats = re.search('(.).\\1', a_str)
        return pair and repeats
    lines = data.split()
    out_a, out_b = 0, 0
    for a_str in lines:
        if is_nice_a(a_str):
            out_a += 1
        if is_nice_b(a_str):
            out_b += 1
    return out_a, out_b


def problem_6(data):
    """problem_6('turn on 0,0 through 999,999') -> 1000000"""
    Op = Enum('Op', 'on off toggle')
    def get_op(line):
        for op in Op:
            if op.name in line:
                return op
    def get_p(a_match):
        return P(int(a_match.group(1)), int(a_match.group(2)))
    def turn(grid, nw, se, on):
        for x in range(nw.x, se.x+1):
            for y in range(nw.y, se.y+1):
                grid[x][y] = on
    def toggle(grid, nw, se):
        for x in range(nw.x, se.x+1):
            for y in range(nw.y, se.y+1):
                grid[x][y] = not grid[x][y]
    lines = data.split('\n')
    grid = [[False for _ in range(1000)] for _ in range(1000)]
    for line in lines:
        op = get_op(line)
        nw_match = re.search('.*?(\d+),(\d+)', line)
        se_match = re.search('(\d+),(\d+)$', line.strip())
        nw, se = get_p(nw_match), get_p(se_match)
        if op == Op.toggle:
            toggle(grid, nw, se)
        else:
            turn(grid, nw, se, op == Op.on)
    return sum(sum(a) for a in grid)


